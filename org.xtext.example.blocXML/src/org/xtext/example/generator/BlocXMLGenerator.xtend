/*
 * generated by Xtext 2.29.0
 */
package org.xtext.example.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.util.List
import org.xtext.example.Bloc
import java.util.ArrayList
import org.xtext.example.Voisin
import org.xtext.example.blocXML.Component
import org.xtext.example.blocXML.Node
import java.util.HashSet
import java.util.Stack

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class BlocXMLGenerator extends AbstractGenerator {
	//Declaration de types
	 List<Bloc> components = new ArrayList<Bloc>();
	 Bloc b;
	 Voisin v;
	ArduinoCodeGenerator generator = new ArduinoCodeGenerator();	
	
	
//Methode a appeler par le fichier source.xml	
override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {	
		
		//parsing du fichier source; extraction des components 
		for (c : resource.allContents.filter(Component).toList) {
			b = new Bloc()
			b.idCompo = c.compoId
			b.idt = c.compoIdt
			components.add(b);
		}
		
		//Parsing des nodes et extraction des neighbours (Voisins)
		for (node : resource.allContents.filter(Node).toList) {
			for (compo : components) {
				if(node.nodeName.split("~").contains(compo.idCompo)){
					for (link : node.links) {
						if (link.compID != compo.idCompo){
							v = new Voisin()
							v.idCompo = link.compID
							v.type = link.portName2
							compo.voisins.add(v)
						}
					}
				}
			}
		}
		
		//Trier pour determiner l'ordre d'appel, génération du code pour chaque blocs
		if (components.size > 0) {
			//HashSet des blocs visités
			val visited = new HashSet<Bloc>()
			//pile des blocs triés
			var stack = new Stack<Bloc>()
			
			
			//Trier les blocs
			for (compo : components) {
				if (!visited.contains(compo)) {
					topologicalSort(compo, visited, stack)
				}
			}
			
			/*Determiner le type de bloc & voisin:
			 * 1** Input : s'il n'a pas de port d'entrée
			 * 2** Output: s'il n'a pas de port de sortie
			 * 3** Inter: s'il a 1..* ports d'entrée & 1..* ports de sortie
			 */
			setBlocType(stack)
			setVoisinType(stack)
		
			/* Generation du fichier a compiler par l'arduino "*.ino" 
			 * Le format du fichier pourrait etre raffiner ex: "Code.py" pour le format python
			 * en definissant une class PythonCodeGenerator.xtend
			 * */
		    fsa.generateFile("code.ino",generator.ArduinoCodeGen(stack)) 	
			
			
			//Nettoyage
			generator.ArduinoCodeClear()
			stack.clear
			components.clear
		}
		
	}
	

	//Algorithme de trie des blocs
	def void topologicalSort(Bloc current, HashSet<Bloc> visited, Stack<Bloc> stack) {
		visited.add(current)
		if (current.voisins != null) {
			for (voisin : current.voisins) {
				val voisinBloc = components.findFirst[bloc | bloc.idCompo == voisin.idCompo]
				if (voisinBloc != null && !visited.contains(voisinBloc)) {
					topologicalSort(voisinBloc, visited, stack)
				}
			}
		}
		
		stack.push(current)
	}
	
	
	
	//Definir le type des blocs
	def void setBlocType(Stack<Bloc> stack){
		var in = false;
		var out = false;
		
		for (b : stack) {
			for (v : b.voisins) {
				if(v.type=="out")
					out = true;
				if(v.type=="in")
					in = true;		
			}	
		if(in && out)
			b.blocType="inter"
		if(in && !out)
			b.blocType="in"
		if(!in && out)
			b.blocType="out"		
		
		//reinitialisation des bool
		in = false;
		out = false;
		}
		
	}


	// Definir le type des voisins
	def setVoisinType(Stack<Bloc> stack){
	for (bloc : stack) {
		for (voisin : bloc.voisins) {
			for (tempBloc : stack) {
				if(tempBloc.idCompo==voisin.idCompo)
					voisin.blocType=tempBloc.blocType
			}
		}
	}
}

}
